import React from "react";
import Phaser from "phaser";
import { GameComponent } from "../../components/GameComponent";
import * as Tone from "tone";
import yellow_circle from "../../assets/particles/yellow.circular.png";
import blue_circle from "../../assets/particles/red.circular.png";
import * as Use from "./Utils";
import images from "./images.js";//how to import all images from a folder? by writing import * as images from "../../assets/images/*.png"; this will import all images from the folder and store them in an object called images, which is automatically generated by the import statement
import soundSources from "./soundsources.js";//does this import them as an array of sound or of 

class Play extends Phaser.Scene {
    constructor(scene) {
        super("Play");
    }

    create() {
        console.log(soundSources);
        console.log(images);

        let startButton = this.add.text(this.scale.width / 2, this.scale.height / 2, 'Play', {
            font: '64px Arial',
            fill: '#ffffff'
        }).setInteractive().setOrigin(0.5);

        startButton.on('pointerdown', () => {
            this.scene.start('Scene1');
            Tone.start(); 
        });
    }
}


class Scene1 extends Phaser.Scene {
    constructor() {
        super("Scene1");
        this.imagesArray = [];
        this.soundsArray = [];
    }

    //lets use tone in this project. so, its imported. now, lets use it by creating a synth and playing a note.. but first i need to start the tone context. how to do that? by writing Tone.start(), because Tone.start() starts the audio context. whcih i need to do first before i can play a note.,

  ; //to make this avilable

    preload() {

        this.load.image("yellow", yellow_circle);
        this.load.image("blue", blue_circle);

        images.forEach(({ name, path }) => {
            this.load.image(name, path);
            this.imagesArray.push(name);
           
        });
        console.log(this.imagesArray);

        soundSources.forEach((name, path) => {
            this.load.audio(name, path);
            this.soundsArray.push(name);
        });
        console.log(this.soundsArray);
  
    }

    
    create() {
        console.log(images);
        //disable gravity
        this.matter.world.disableGravity();
        this.matter.world.setBounds();
        this.matter.add.mouseSpring();

        //store canvas dimensions
        const width = this.scale.width;
        const height = this.scale.height;
       
        
        
        function randomColor() {
            return '0x' + ('00000' + (Math.random() * (1 << 24) | 0).toString(16)).slice(-6);
        };

        function rangeMapper(value, low1, high1, low2, high2) {
            return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
        }
        
        let newEmitter; //declare emitter for accessible scope in pointer events
        let granularSynth = new Tone.GrainPlayer({
            url:  "./assets/Sounds/Sea Song Lullaby.mp3", // create a bunch of alt slices? maek them short, let's say 5 seconds each? can randomize. experiment with how long a file matters for infinitum variety.  
            loop: true, // Default: false. Type: Boolean
            grainSize: 0.2, //map to lifespan 1000,4000  
            overlap: 0.1, // map to frequency Math.random() * .5 + .01. can i do {min: .01, max: 5} like emitter? will see. Also maybe best to map values between ranges. 
            playbackRate: 1, // map to speed
            reverse: false, // map to scale, scale start < scale end, do true
            detune: 0, // map to alpha (higher alpha start, higher tuning, lower alpha (i.e. darker), lower tuning)
            drift: 0, // map to lifespan 
            spread: 0, //map to speed . 0 to 1
            attack: 0.3, // maybe default, but experiment. Default value not specified; this is a suggested starting point. Type: Number, Range: 0 to 1
            release: 0.3, // Default value not specified; this is a suggested starting point. Type: Number, Range: 0 to 1
            volume: -10, // Default value not specified; this is a suggested starting point. Type: Number, Range: -60 to 0
            // onStart: () => {}, // No default action. Type: Function
            // onLoop: () => {}, // No default action. Type: Function
            // onEnd: () => {}, // No default action. Type: Function
          }).toDestination();//use set

          //to set Tone.GrainPlayer to a new config, 

        //reverb?


  
        this.input.on("pointerdown", (pointer) => {
            const color1 = randomColor();
            const color2 = randomColor();
            const color3 = randomColor();
            console.log(color1, color2);
            newEmitter = this.add.particles(0, 0, this.imagesArray[Math.floor(Math.random() * this.imagesArray.length)], { 
                speed: { min: 20 + (Math.random() * 30), max: (Math.random() * 230) }, 
                frequency: (Math.random() * 15) + .5, 
                scale: { start: Math.random() * .25, end: Math.random() * .25}, 
                lifespan:  { min: 1000, max: 4000 }, //try 10000 outer bound 
                color: [color1, color2, color3], 
                colorEase: Math.random * 1, 
                alpha: {start: .7 + (Math.random() * .3), end: Math.random() * .2}, //math.random is exclusvie or inclusive of 1? it 
                blendMode: "SCREEN",
              //  blendMode: "ADD", //other options and their effects are here: https://newdocs.phaser.io/docs/3.70.0/Phaser.BlendModes
                follow: pointer,
                emitting: true,
            });
            console.log(newEmitter);

            granularSynth.set({
                    url: this.soundsArray[Math.floor(Math.random() * this.soundsArray.length)], //to specify using the path of the sound, add .pa
                    overlap: 0.1, // map to frequency Math.random() * .5 + .01. can i do {min: .01, max: 5} like emitter? will see. Also maybe best to map values between ranges. 
                    playbackRate: 1, // map to speed
                    reverse: false, // map to scale, scale start < scale end, do true
                    detune: 0, // map to alpha (higher alpha start, higher tuning, lower alpha (i.e. darker), lower tuning)
                    drift: 0, // map to lifespan 
                    spread: 0, //map to speed . 0 to 1
                    attack: 0.3, // maybe default, but experiment. Default value not specified; this is a suggested starting point. Type: Number, Range: 0 to 1
                    release: 0.3, // Default value not specified; this is a suggested starting point. Type: Number, Range: 0 to 1
                    // onStart: () => {}, // No default action. Type: Function
                    // onLoop: () => {}, // No default action. Type: Function
                    // onEnd: () => {}, // No default action. Type: Function
                  }).start();

            ///test if these are necessary now that we're declarig new emitter in this pointerdown function
            newEmitter.follow = pointer;
            newEmitter.emitting = true;
            //initiate a .3 second fade in of the emittter.
            

        });

        this.input.on("pointerup", () => {
            if (!newEmitter) return;

            newEmitter.emitting = false;//it can't
            granularSynth.stop();// 
        });

        //FULLSCREEN
        const button = this.add.image(.9 * width, .1 * height, 'fullscreen', 0).setInteractive(); //how to set the frame to 0? by writing 
        // const eyelet = this.add.sprite(.5 * width, .5 * height, 'eyelet', 0).setInteractive(); //how to set the frame to 0? by writing
        button.on('pointerup', function ()
            {

                if (this.scale.isFullscreen)
                {
                    button.setFrame(0);

                    this.scale.stopFullscreen();
                }
                else
                {
                    button.setFrame(1);

                    this.scale.startFullscreen();
                }

            }, this);

    }
}


    

    
    
   

export const SoftTouch = () => {
    //config
    const config = {
        type: Phaser.AUTO,
        parent: "phaser-container",
        width: "100%",
        height: "95%", //why does 100% make it below the fold?
        scene: [Play, Scene1],
        scale: {
            mode: Phaser.Scale.FIT,
            parent: 'phaser-example',
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width: "100%",
            height: "95%"
        },
        physics: {
            default: "matter", //matter is a physics engine that comes with Phaser
            matter: {
                enableSleeping: true,
                debug: true,
            }
        },
    };

    //render gamecomponent
    return (
        <div>
            <GameComponent config={config} />
        </div>
    );
};
